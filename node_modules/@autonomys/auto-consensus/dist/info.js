"use strict";
// file: src/info.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockchainSize = exports.spacePledge = exports.maxPiecesInSector = exports.slotProbability = exports.segmentCommitment = exports.shouldAdjustSolutionRange = exports.solutionRanges = exports.networkTimestamp = exports.blockHash = exports.blockNumber = exports.block = exports.query = exports.rpc = void 0;
exports.solutionRangeToSectors = solutionRangeToSectors;
const query_1 = require("./utils/query");
const PIECE_SIZE = BigInt(1048576);
const rpc = (api_1, methodPath_1, ...args_1) => __awaiter(void 0, [api_1, methodPath_1, ...args_1], void 0, function* (api, methodPath, params = []) { return yield (0, query_1.queryMethodPath)(api, `rpc.${methodPath}`, params); });
exports.rpc = rpc;
const query = (api_1, methodPath_1, ...args_1) => __awaiter(void 0, [api_1, methodPath_1, ...args_1], void 0, function* (api, methodPath, params = []) { return yield (0, query_1.queryMethodPath)(api, `query.${methodPath}`, params); });
exports.query = query;
const block = (api) => __awaiter(void 0, void 0, void 0, function* () { return yield (0, exports.rpc)(api, 'chain.getBlock', []); });
exports.block = block;
const blockNumber = (api) => __awaiter(void 0, void 0, void 0, function* () {
    // Get the block
    const _block = yield (0, exports.block)(api);
    return _block.block.header.number.toNumber();
});
exports.blockNumber = blockNumber;
const blockHash = (api) => __awaiter(void 0, void 0, void 0, function* () {
    const _blockHash = yield (0, exports.rpc)(api, 'chain.getBlockHash', []);
    return _blockHash.toString();
});
exports.blockHash = blockHash;
const networkTimestamp = (api) => __awaiter(void 0, void 0, void 0, function* () { return yield (0, exports.query)(api, 'timestamp.now', []); });
exports.networkTimestamp = networkTimestamp;
const solutionRanges = (api) => __awaiter(void 0, void 0, void 0, function* () {
    const _solutionRanges = yield (0, exports.query)(api, 'subspace.solutionRanges', []);
    const solution = _solutionRanges.toPrimitive();
    return {
        current: solution.current ? BigInt(solution.current) : null,
        next: solution.next ? BigInt(solution.next) : null,
        votingCurrent: solution.votingCurrent ? BigInt(solution.votingCurrent) : null,
        votingNext: solution.votingNext ? BigInt(solution.votingNext) : null,
    };
});
exports.solutionRanges = solutionRanges;
const shouldAdjustSolutionRange = (api) => __awaiter(void 0, void 0, void 0, function* () { return yield (0, exports.query)(api, 'subspace.shouldAdjustSolutionRange', []); });
exports.shouldAdjustSolutionRange = shouldAdjustSolutionRange;
const segmentCommitment = (api) => __awaiter(void 0, void 0, void 0, function* () { return yield (0, exports.query)(api, 'subspace.segmentCommitment', []); });
exports.segmentCommitment = segmentCommitment;
const slotProbability = (api) => api.consts.subspace.slotProbability.toPrimitive();
exports.slotProbability = slotProbability;
const maxPiecesInSector = (api) => BigInt(api.consts.subspace.maxPiecesInSector.toPrimitive());
exports.maxPiecesInSector = maxPiecesInSector;
function solutionRangeToSectors(solutionRange, slotProbability, piecesInSector) {
    const MAX_U64 = BigInt(Math.pow(2, 64) - 1);
    const RECORD_NUM_CHUNKS = BigInt(32768);
    const RECORD_NUM_S_BUCKETS = BigInt(65536);
    const sectors = ((MAX_U64 / slotProbability[1]) * slotProbability[0]) /
        ((piecesInSector * RECORD_NUM_CHUNKS) / RECORD_NUM_S_BUCKETS);
    return sectors / solutionRange;
}
const spacePledge = (api) => __awaiter(void 0, void 0, void 0, function* () {
    const _solutionRanges = yield (0, exports.solutionRanges)(api);
    const _slotProbability = (0, exports.slotProbability)(api);
    const _maxPiecesInSector = (0, exports.maxPiecesInSector)(api);
    if (!_solutionRanges.current || !_slotProbability || !_maxPiecesInSector)
        return 0;
    const sectors = solutionRangeToSectors(_solutionRanges.current, [BigInt(_slotProbability[0]), BigInt(_slotProbability[1])], _maxPiecesInSector);
    const totalSpacePledged = sectors * _maxPiecesInSector * PIECE_SIZE;
    return totalSpacePledged;
});
exports.spacePledge = spacePledge;
const blockchainSize = (api) => __awaiter(void 0, void 0, void 0, function* () {
    const _segmentCommitment = yield (0, exports.segmentCommitment)(api);
    const segmentsCount = BigInt(_segmentCommitment.length);
    const blockchainSize = PIECE_SIZE * BigInt(256) * segmentsCount;
    return blockchainSize;
});
exports.blockchainSize = blockchainSize;
